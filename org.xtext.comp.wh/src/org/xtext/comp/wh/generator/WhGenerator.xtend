/*
 * generated by Xtext 2.15.0
 */
package org.xtext.comp.wh.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.comp.wh.wh.Commands
import org.xtext.comp.wh.wh.Definition
import org.xtext.comp.wh.wh.Function
import org.xtext.comp.wh.wh.Program
import org.xtext.comp.wh.wh.Command
import org.xtext.comp.wh.wh.While
import org.xtext.comp.wh.wh.Nop
import org.xtext.comp.wh.wh.Expr
import org.xtext.comp.wh.wh.ExprAnd
import org.xtext.comp.wh.wh.ExprOr
import org.xtext.comp.wh.wh.ExprNot
import org.xtext.comp.wh.wh.ExprEq
import org.xtext.comp.wh.wh.ExprSimple
import org.xtext.comp.wh.wh.LExpr
import org.xtext.comp.wh.wh.If
import org.xtext.comp.wh.wh.For
import org.xtext.comp.wh.wh.Foreach
import org.xtext.comp.wh.wh.Assign
import org.xtext.comp.wh.wh.Exprs

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhGenerator extends AbstractGenerator {
	
	var String default_indentation;
	var String while_indentation;
	var String if_indentation;
	var String for_indentation;
	var String foreach_indentation;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		doGenerate(resource, fsa, context, "output.wh", 2, 2, 2, 2, 2);
	}

	def doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String output, int nb_default_indent, int nb_if_indent, int nb_while_indent, int nb_for_indent, int nb_foreach_indent) {
		default_indentation= "";
		while_indentation= "";
		for_indentation= "";
		if_indentation= "";
		foreach_indentation= "";
		
		for(var i = 0; i < nb_default_indent; i++) {
			default_indentation += " "
		}
		for(var i = 0; i < nb_while_indent; i++) {
			while_indentation += " "
		}
		for(var i = 0; i < nb_for_indent; i++) {
			for_indentation += " "
		}
		for(var i = 0; i < nb_foreach_indent; i++) {
			foreach_indentation += " "
		}
		for(var i = 0; i < nb_if_indent; i++) {
			if_indentation += " "
		}
		
		for(p : resource.allContents.toIterable.filter(Program)) {
			fsa.generateFile(output, p.compile())
		}
	}
	
	def compile(Program p) '''
	«FOR f : p.functions SEPARATOR "\n"»
	«f.compile()»
	«ENDFOR»
	'''
	
	def compile(Function f) '''
	function «f.fname»:
	«f.definition.compile()»
	'''
	
	def compile(Definition d)'''
	read «FOR param : d.inputs.params SEPARATOR ", "»«param»«ENDFOR»
	%
	«d.commands.compile(default_indentation)»
	%
	write «FOR r_value : d.outputs.r_values SEPARATOR ", "»«r_value»«ENDFOR»
	'''
	
	
	def compile(Commands c, String indent) {
		val nb_commands = c.command.size;
		var counter = 0;
		var commands = ""
		
		for (command : c.command) {
			counter++;
			
			if(counter == nb_commands) {
				commands += command.compile(indent)
			} else {
				commands += command.compile(indent) + " ;";
			}
			commands += "\n";
		}
		
		return commands
		
	}
	
	def compile(Command c, String indent) {
		if(c.command instanceof While) {
			return (c.command as While).compile(indent)
		} else if(c.command instanceof Nop) {
			return indent+"nop"
		} else if(c.command instanceof If) {
			return (c.command as If).compile(indent)
		} else if(c.command instanceof For) {
			return (c.command as For).compile(indent)
		} else if(c.command instanceof Foreach) {
			return (c.command as Foreach).compile(indent)
		} else if(c.command instanceof Assign) {
			return (c.command as Assign).compile(indent)
		}
		
	}
	
	def compile(While wh, String indent)'''
	«indent»while «wh.cond.compile()» do
	«wh.commands.compile(indent+while_indentation)»
	«indent»od'''
	
	def compile(For fo, String indent)'''
	«indent»for «fo.cond.compile()» do
	«fo.commands.compile(indent+for_indentation)»
	«indent»od'''
	
	def compile(Foreach foreach, String indent)'''
	«indent»foreach «foreach.expr.compile()» in «foreach.e2.compile» do
	«foreach.commands.compile(indent+foreach_indentation)»
	«indent»od'''
	
	def compile(If i, String indent) {
		var expr = indent+"if " + i.cond.compile() + " then\n" + i.if_commands.compile(indent+if_indentation);
		if(i.else_commands !== null) {
			expr += indent+"else\n" + i.else_commands.compile(indent+if_indentation);
		}
		expr += indent+"fi";
		return expr;
		
	}
	
	def compile(Assign assign, String indent)'''
	«indent»«FOR variable : assign.vars.variables SEPARATOR ","»«variable»«ENDFOR» := «assign.exprs.compile()»'''
	
	
	def compile(Expr e)'''
	«e.expr_and.compile()»'''
	
	def compile(Exprs exprs)'''
	«FOR expr : exprs.expr SEPARATOR ","»«expr.compile()»«ENDFOR»'''
	
	def compile(ExprAnd ea)'''
	«FOR expr : ea.expr_or SEPARATOR " and "»«expr.compile()»«ENDFOR»'''
	
	def compile(ExprOr eo)'''
	«FOR expr : eo.expr_not SEPARATOR " and "»«expr.compile()»«ENDFOR»'''
	
	def compile(ExprNot en){
		var expr = "";
		if(en.hasNot !== null) {
			expr += "not "
		}
		expr += en.expr_eq.compile()
		return expr
	}
	
	def compile(ExprEq eq){
		var String expr = "";
		if(eq.expr_left !== null) {
			expr += eq.expr_left.compile();
			if(eq.expr_right !== null) {
				expr += " ?= " + eq.expr_right.compile();
			}
		} else if(eq.sym !== null){
			expr += "(" + eq.sym + " " + eq.lexpr.compile() + ")"
			
		} else {
			expr += "(" + eq.expr.compile() + ")";
		}
		return expr;
	}
	
	def compile(ExprSimple es) {
			if(es.nil !== null) {
				return "nil";
			} else if(es.variable !== null) {
				return es.variable
			} else if(es.sym !== null) {
				return es.sym
			} else if(es.cons_exp !== null) {
				return "(cons " + es.cons_exp.compile() + ")"
			} else if (es.list_exp !== null) {
				return "(list " + es.list_exp.compile() + ")"
			} else if (es.hd_expr !== null) {
				return "(hd " + es.hd_expr.compile() + ")"
			} else if (es.tl_expr !== null) {
				return "(tl " + es.tl_expr.compile() + ")"
			}
	}
	
	def compile(LExpr lexpr)'''
	«FOR expr : lexpr.expr  SEPARATOR " "»«expr.compile() »«ENDFOR»'''
	
	

}
