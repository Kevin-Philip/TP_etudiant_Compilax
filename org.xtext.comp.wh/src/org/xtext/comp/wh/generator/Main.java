/*
 * generated by Xtext 2.15.0
 */
package org.xtext.comp.wh.generator;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.GeneratorDelegate;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.xtext.comp.wh.WhStandaloneSetup;

public class Main {
	
	public static String getErrorOpt(String opt) {
		return "Option invalide " + opt + ", veuillez vous reférez au manuel -help";
	}
	
	public static String getErrorArg(String arg, String val) {
		return "Argument invalide \"" + val + "\" pour " + arg + ", veuillez vous reférez au manuel -help";
	}

	public static void main(String[] args) {
		if (args.length == 0) {
			System.err.println("Pas de fichier d'entrée précisé.");
			return;
		}

		// Default Values
		final int DEFAULT_INDENT_ALL = 2;
		final String DEFAULT_OUTPUT_NAME = "sth.whpp";
		
		final List<String> ARGS = new ArrayList<>(Arrays.asList("-all", "-if", "-while", "-for", "-foreach", "-o", "-help"));

		// Values
		String fileName = args[0];
		String outputName = DEFAULT_OUTPUT_NAME;
		int indentAll = DEFAULT_INDENT_ALL;
		int indentIf = DEFAULT_INDENT_ALL;
		int indentWhile = DEFAULT_INDENT_ALL;
		int indentFor = DEFAULT_INDENT_ALL;
		int indentForeach = DEFAULT_INDENT_ALL;
		
		
		// Check if input file is ok
		
		if(!(new File(fileName)).exists()) {
			System.err.println("Le fichier d'entrée n'existe pas.");
			return;
		}
		
		if(!fileName.endsWith(".wh")) {
			System.err.println("Le fichier doit se terminer par l'extension .wh");
			return;
		}

		// Parsing options
		for (int i = 1; i < args.length; i++) {
			if (args[i].charAt(0) == '-') {
				
				if(!ARGS.contains(args[i])) {
					System.err.println(getErrorOpt(args[i]));
					return;
				}

				// Bad option (only '-')
				if (args[i].length() < 2) {
					System.err.println("Erreur à l'argument " + args[i]);
					return;
				}
				
				// No argument for option
				if ((i+1)==args.length) {
					System.err.println("Argument non précisé pour " + args[i]);
					return;
				}
				
				String option = args[i].substring(1);
				switch (option) {
				case "all":
					if (args[i + 1].matches("\\d+")) {
						i++;
						indentAll = Integer.parseInt(args[i]);
						//System.out.println("all "+Integer.parseInt(args[i]));
					}else {
						System.err.println(getErrorArg(args[i], args[i+1]));
						return;
						
					}
					break;
				case "if":
					if (args[i + 1].matches("\\d+")) {
						i++;
						indentIf = Integer.parseInt(args[i]);
						//System.out.println("if "+Integer.parseInt(args[i]));

					}else {
						System.err.println(getErrorArg(args[i], args[i+1]));
						return;
					}
					break;
				case "while":
					if (args[i + 1].matches("\\d+")) {
						i++;
						indentWhile = Integer.parseInt(args[i]);
						//System.out.println("while "+Integer.parseInt(args[i]));

					}else {
						System.err.println(getErrorArg(args[i], args[i+1]));
						return;
					}
					break;
				case "for":
					if (args[i + 1].matches("\\d+")) {
						i++;
						indentFor = Integer.parseInt(args[i]);
						//System.out.println("for "+Integer.parseInt(args[i]));

					}else {
						System.err.println(getErrorArg(args[i], args[i+1]));
						return;
					}
					break;
				case "foreach":
					if (args[i + 1].matches("\\d+")) {
						i++;
						indentForeach = Integer.parseInt(args[i]);
						//System.out.println("foreach "+Integer.parseInt(args[i]));

					}else {
						System.err.println(getErrorArg(args[i], args[i+1]));
						return;
					}
					break;
				case "o":
					i++;
					outputName = args[i];
					//System.out.println("output "+args[i]);
					break;
				}

			} else {
				System.err.println(getErrorOpt(args[i]));
				return;
			}
		}
		
		if((new File(outputName)).exists()) {
			while(true) {
				System.out.println("Le fichier " + outputName + " existe, voulez-vous l'écraser ? (Y/N) : ");
				Scanner sc = new Scanner(System.in);
				String response = sc.nextLine().toLowerCase();
				if(response.equals("y") || response.equals("yes")) {
					break;
				} else if(response.equals("n") || response.equals("no")) {
					return;
				}
			}
		}
		Injector injector = new WhStandaloneSetup().createInjectorAndDoEMFRegistration();
		Main main = injector.getInstance(Main.class);
		boolean hasError = main.runGenerator(fileName,outputName,indentAll,indentIf,indentWhile,indentFor,indentForeach);
		
		if(hasError) return;
		
		BufferedReader r;
		try {
			r = new BufferedReader(new FileReader(outputName));
			String s = "", line = null;
			while ((line = r.readLine()) != null) {
			    s += line + "\n";
			}
			System.out.print(s);
		} catch (Exception e) {
			System.out.println("Problème lors de l'ouvertue du fichier créé.");
			return;
		}
		
	}

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	@Inject
	private WhGenerator generator;

	@Inject
	private JavaIoFileSystemAccess fileAccess;

	protected boolean runGenerator(String fileName,String outputName,int indentAll,int indentIf,int indentWhile,int indentFor,int indentForeach) {
		// Load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createFileURI(fileName), true);
		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return true;
		}

		// Configure and start the generator
		fileAccess.setOutputPath("./");
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		generator.doGenerate(resource, fileAccess, context,outputName,indentAll,indentIf,indentWhile,indentFor,indentForeach );
		return false;
	}
}
